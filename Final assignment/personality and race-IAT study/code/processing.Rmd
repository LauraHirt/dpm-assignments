---
title: "Examining the relationship between the big-5 personality facets and implicit racial attitudes"
subtitle: "Data processing"
author: "Template: Laura Hirt; content: Laura Hirt"
date: "2023-12-18"
output:
  html_document:
    code_folding: hide
    highlight: haddock
    theme: flatly
    toc: yes
    toc_float: yes
---

```{r, include=FALSE}

knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE)

```

# Dependencies

```{r}
library(tidyverse)
library(janitor)
library(stringr)
library(xlsx) 
library(rJava)
library(xlsxjars)
library(psych)
library(car)
library(stats)
```

# Get data

```{r}
# demographics
data_demographic_raw <- read_csv("../data/raw/data_raw_demographics.csv") %>%
  janitor::clean_names()

# BFI
data_bfi_raw <- read_csv("../data/raw/data_raw_bfi.csv") %>%
  janitor::clean_names()

# IAT
data_iat_raw <- read_csv("../data/raw/data_raw_iat.csv",
                        skip = 1) %>% # skip first line when reading in the data
  janitor::clean_names()
```

# Demographics

Age and gender have to be extracted from the raw demographics data which are both stored in a variable called "variable". To get to two independent variables, I use pivot_wider. As it only makes sense to extract the gender and age of people with known ID which can be identified, cases with missing ID are filtered out. Values other than male or female in the gender variable and other than numeric input in the age variable are set to other/missing/error to be easily identified to exclude later.

```{r}
data_age_gender <- data_demographic_raw %>%
  select(unique_id, variable, response) %>%
  filter(!is.na(unique_id)) %>%
  pivot_wider(names_from = variable,
              values_from = response) %>%
  rename(gender = sex) %>%
  mutate(gender = case_when(gender == "f" ~ gender,
                            gender == "m" ~ gender,
                            TRUE ~ "other/missing/error"),
         age = case_when(str_detect(age, "^[0-9]+$") ~ age, 
                         TRUE ~ "other/missing/error")) 
```

# BFI

Each participant was asked to complete between 2 and 3 of the big-five personality sub-scales. Each sub-scale consists of between 8 and 10 items.

## Reverse scoring of the negatively worded items

In order to counteract response tendencies, various items per sub-scale were formulated negatively so that conspicuous response patterns can be identified. However, before these item-level values can be meaningfully calculated into average values, negatively worded items must first be re-coded.

The following items per sub-scale are re-coded below:

-   Extraversion scale (bfi_e): Items 2, 5, 7

-   Conscientiousness scale (bfi_c): Items 2, 4, 5, 9

-   Neuroticism scale (bfi_n): Items 2, 5, 7

-   Agreeableness scale (bfi_a): Items 1, 3, 6, 8

-   Openness scale (bfi_o): Items 7, 9

Each item can take on values from 1 to 6 (1 \<- 6; 2 \<- 5; 3 \<- 4; 4 \<- 3; 5 \<- 2; 6 \<- 1)

```{r}
# Define vector of items to be reversed
reverse_items <- c("bfi_e2","bfi_e5","bfi_e7","bfi_c2","bfi_c4","bfi_c5","bfi_c9","bfi_n2","bfi_n5", "bfi_n7","bfi_a1", "bfi_a3","bfi_a6","bfi_a8","bfi_o7","bfi_o9")

# Define the Reverse Scoring Function
reverse_score <- function(x) {
    7 - x
}

# Apply Function to the Specified Columns with mutate and across to apply the reverse scoring function to the specified items in the dataset. 
data_bfi_recoded <- data_bfi_raw %>%
    mutate(across(all_of(reverse_items), reverse_score))
```

### Sanity check

The items of the sub-scales should all be coded in the same direction after recoding, so that higher values of an item also correspond to higher values of the construct. To check whether the recoding of the inverse-coded items was successful, a correlation matrix of the items is now created for each sub-scale. If the items have been re-coded correctly, all correlations of the items within a scale should be positive.

```{r}
# Extraversion scale
extraversion <- data_bfi_recoded %>%
  select(starts_with("bfi_e"))
# Correlation extraversion items
cor(extraversion, method = "pearson", use = "complete.obs")

# Conscientiousness scale
conscientiousness <- data_bfi_recoded %>%
  select(starts_with("bfi_c"))
# Correlation conscientiousness items
cor(conscientiousness, method = "pearson", use = "complete.obs")

# Neuroticism scale
neuroticism <- data_bfi_recoded %>%
  select(starts_with("bfi_n"))
# Correlation neuroticism items
cor(neuroticism, method = "pearson", use = "complete.obs")

# Agreeableness scale
agreeableness <- data_bfi_recoded %>%
  select(starts_with("bfi_a"))
# Correlation agreeableness items
cor(agreeableness, method = "pearson", use = "complete.obs")

# Openness scale
openness <- data_bfi_recoded %>%
  select(starts_with("bfi_o"))
# Correlation openness items
cor(openness, method = "pearson", use = "complete.obs")
```

**Interpretation:**

In the sub-scales of extraversion, conscientiousness, agreeableness and neuroticism, all correlations of the items were positive. This indicates that the re-coding of the inverse-coded items was successful.

Only the correlation between items 7 and 10 of the openness sub-scale was negative (-0.0997). However, the value of this correlation is so low that it can be assumed that it does not deviate significantly from zero and therefore the negative sign has no meaning in terms of content.

## Exclusion variable item-level data

It has to be checked that the item-level data does not violate the logical min. and max. scores (1 to 6). An exclusion variable is created which sets participants with impossible data to "exclude" while participants with possible data are set to "include". As all participants only had to complete 2 to 3 of the sub-scales of the questionnaire, they all had missing values for certain sub-scales. These are therefore not taken into account in the assessment.

```{r}
data_bfi_item_level <- data_bfi_raw %>%
  rowwise() %>%
  mutate(exclude_bfi_item_violation = ifelse(any(c_across(starts_with("bfi")) < 1 | 
                                                 c_across(starts_with("bfi")) > 6,
                                                 na.rm = TRUE), 
                                             "exclude", "include")) %>%
  ungroup() %>%
  select(unique_id, exclude_bfi_item_violation)
```

**Interpretation:**

It can be seen that three of the participants are to be excluded from the study because their answers contain invalid values (0 and/or 7).

## Exclusion variable completeness of BFI scales

It has to be checked that participants have complete data on the BFI scales they completed (2 to 3 scales per participant). Therefore I create a single exclusion variable (exclusion_scale_level) , where participants are set to "exclude" if they have incomplete data in any of the sub-scales they attempted and "include" otherwise. This involves checking each sub-scale for completeness only among those participants who have attempted it and then aggregating these checks into a single exclusion decision.

```{r}
# Items
items <- data_bfi_raw %>%
  select(-unique_id)

# Function to check if a subscale is attempted and incomplete
# The function checks if any subscale is both attempted (at least one non-NA response) and incomplete (contains NA responses).
is_attempted_incomplete <- function(items) {
  any(!is.na(items)) && any(is.na(items))
}

# Apply the check for each subscale
data_bfi_scale_level <- data_bfi_raw %>%
  rowwise() %>%
  mutate(
    exclusion_bfi_scale_level = ifelse(
      is_attempted_incomplete(c_across(starts_with("bfi_e"))) |
      is_attempted_incomplete(c_across(starts_with("bfi_a"))) |
      is_attempted_incomplete(c_across(starts_with("bfi_o"))) |
      is_attempted_incomplete(c_across(starts_with("bfi_c"))) |
      is_attempted_incomplete(c_across(starts_with("bfi_n"))),
      "exclude", "include"
    )
  ) %>%
  ungroup() %>%
  select(unique_id, exclusion_bfi_scale_level)

```

**Interpretation:**

Inspection of the exclusion variable shows that 10 participants have partially completed sub-scales and must therefore be excluded from any subsequent analysis.

## Mean-scores of sub-scales of the BFI

The sub-scales of the BFI scale (2 to 3 sub-scales per participant) are to be mean-scored. If a participant has not completed a sub-scale, the resulting mean-score equals NA and can be excluded in further analyses.

```{r}
data_bfi_means <- data_bfi_recoded %>%
  rowwise() %>%
  mutate(
    mean_extroversion = mean(c_across(starts_with("bfi_e")), na.rm = TRUE),
    mean_agreeableness = mean(c_across(starts_with("bfi_a")), na.rm = TRUE),
    mean_openness = mean(c_across(starts_with("bfi_o")), na.rm = TRUE),
    mean_conscientiousness = mean(c_across(starts_with("bfi_c")), na.rm = TRUE),
    mean_neuroticism = mean(c_across(starts_with("bfi_n")), na.rm = TRUE)) %>%
  ungroup() %>%
  select(unique_id, mean_extroversion, mean_agreeableness, mean_openness, mean_conscientiousness, mean_neuroticism)
```

### Sanity check

The various sub-scales each contain between 8 and 10 items, which can range in value from 1 to 6. In order to check whether the creation of the average value of the scales per participant was successful, it can be checked whether the resulting scale values are within the possible range.

```{r}
data_bfi_means_validity_check <- data_bfi_means %>%
  select(unique_id, mean_agreeableness, mean_conscientiousness, mean_openness,
         mean_extroversion, mean_neuroticism) %>%
  mutate(
    valid_mean_extroversion = mean_extroversion >= 1 & mean_extroversion <= 6,
    valid_mean_agreeableness = mean_agreeableness >= 1 & mean_agreeableness <= 6,
    valid_mean_openness = mean_openness >= 1 & mean_openness <= 6,
    valid_mean_conscientiousness = mean_conscientiousness >= 1 & mean_conscientiousness <= 6,
    valid_mean_neuroticism = mean_neuroticism >= 1 & mean_neuroticism <= 6
  )

any_invalid <- any(data_bfi_means_validity_check$valid_mean_extroversion == FALSE |
                   data_bfi_means_validity_check$valid_mean_agreeableness == FALSE |
                   data_bfi_means_validity_check$valid_mean_openness == FALSE |
                   data_bfi_means_validity_check$valid_mean_conscientiousness == FALSE |
                   data_bfi_means_validity_check$valid_mean_neuroticism == FALSE, na.rm = TRUE)

any_invalid
```

**Interpretation:**

There is no mean-scored variable outside the range of possible scores.

# IAT

The implicit association test (IAT) is an assessment is intended to detect subconscious (implicit) associations between mental representations/concepts of objects in memory. In this study, the focus is on the assessment of implicit stereotypes (associations between racial categories and stereotypes about those groups) held by test subjects.

## Scoring of the trial-level IAT

The IAT data consists of 7 blocks, of which number 1, 2 and 5 are training blocks and must be discarded.

Subsequently, the trial-level IAT data are scored per participant using the Greenwald "D" score:

-   mean RT ("mean1") for blocks 3 and 6

-   mean RT ("mean2") for blocks 4 and 7

-   SD of RT's in blocks 3,4,6, and 7 ("SD")

-   D = (mean2 - mean1)/SD

```{r}
data_iat_scored <- data_iat_raw %>%
  filter(block_number %in% c(3, 4, 6, 7)) %>%
  group_by(unique_id) %>%
  summarize(
    mean1 = mean(trial_reaction_time_in_ms[block_number %in% c(3, 6)], na.rm = TRUE),
    mean2 = mean(trial_reaction_time_in_ms[block_number %in% c(4, 7)], na.rm = TRUE),
    SD = sd(trial_reaction_time_in_ms[block_number %in% c(3, 4, 6, 7)], na.rm = TRUE)
  ) %>%
  mutate(
    D = (mean2 - mean1) / SD
  ) %>%
  select(unique_id, mean1, mean2, SD, D)
```

### Sanity check

It now has to be checked that all D scores are in the range -2 to +2.

```{r}
d_scores_within_range <- all(data_iat_scored$D >= -2 & data_iat_scored$D <= 2)

d_scores_within_range
```

**Interpretation:**

As the value is TRUE, this means that all D scores are within the specified range of -2 to +2.

## Exclusion variable incomplete trial-level IAT

An exclusion variable is created which sets participants with incomplete trial-level IAT data to "exclude", while participants with complete trial-level IAT data are set to "include". After exclusion of the training blocks, the critical test blocks should consist of a total of 120 trials per person.

```{r}
data_iat_trial_level <- data_iat_raw %>%
  filter(block_number %in% c(3,4,6,7)) %>%
  group_by(unique_id) %>%
  count() %>%
  ungroup() %>%
  mutate(exclude_iat_trial_level = ifelse(n == 120, "include", "exclude")) %>%
  select(-n) 
```

**Interpretation:**

Inspection of the exclusion variable shows that 4 participants have a combined trial-number other than 120 trials in the critical test blocks and must therefore be excluded from any subsequent analysis.

## Exclusion variable for IAT performance

An exclusion variable for the IAT performance is created which sets participants with either \>= 10% of trials \< 300ms and/or and accuracy of \<= 75% to "exclude", while other participants are set to "include".

```{r}
data_iat_performance <- data_iat_raw %>%
  filter(block_number %in% c(3, 4, 6, 7)) %>%
  mutate(
    reaction_time_problematic = if_else(trial_reaction_time_in_ms < 300, TRUE, FALSE),
    accuracy_problematic = ifelse(trial_accuracy == "incorrect", TRUE, FALSE)) %>%
  group_by(unique_id) %>%
  summarize(
    proportion_fast_trials_iat = mean(reaction_time_problematic),
    proportion_inaccurate_trials = mean(accuracy_problematic)) %>%
  mutate(
    exclude_iat_performance = ifelse(proportion_fast_trials_iat >= 0.10 | proportion_inaccurate_trials >= 0.25, "exclude", "include")) 
```

**Interpretation:**

Inspection of the exclusion variable shows that 1 participant has both a proportion of trials under 300ms that is too high (46.7 %) and a proportion of inaccurate trials that is too high (38.3%) and therefore has to be excluded from any subsequent analyses.

# Combine

```{r}
# combine all dfs created in the previous chunks
data_processed_combined <- data_age_gender %>%
  full_join(data_bfi_recoded, by = "unique_id") %>% 
  full_join(data_bfi_item_level, by = "unique_id") %>%
  full_join(data_bfi_scale_level, by = "unique_id") %>%
  full_join(data_bfi_means, by = "unique_id") %>%
  full_join(data_iat_scored, by = "unique_id") %>%
  full_join(data_iat_trial_level, by = "unique_id") %>%
  full_join(data_iat_performance, by = "unique_id")


# flag all subjects with more than one row in the wide-format data. these should be excluded in the analysis.
data_processed_duplicates <- data_processed_combined %>%
  count(unique_id) %>%
  mutate(exclude_duplicate_data = if_else(n > 1, "exclude", "include")) %>%
  select(-n)

# join in the duplicates df
data_processed_before_exclusions <- data_processed_combined %>%
  full_join(data_processed_duplicates, by = "unique_id")
```

# Define master exclusions

```{r}
# create a master exclude participant variable
data_processed <- data_processed_before_exclusions %>%
  mutate(exclude_participant = case_when(
      is.na(exclude_bfi_item_violation) | is.na(exclusion_bfi_scale_level) | 
      is.na(exclude_iat_trial_level) | is.na(exclude_iat_performance) | 
      is.na(exclude_duplicate_data) ~ "exclude",
      exclude_bfi_item_violation == "exclude" ~ "exclude",
      exclusion_bfi_scale_level == "exclude" ~ "exclude",
      exclude_iat_trial_level == "exclude" ~ "exclude",
      exclude_iat_performance == "exclude" ~ "exclude",
      exclude_duplicate_data == "exclude" ~ "exclude",
      TRUE ~ "include"))
```

# Write to disk

```{r}
# in case this dir doesn't exist, create it
dir.create("../data/processed/")

# save data to disk in that dir
write_csv(data_processed, "../data/processed/data_processed.csv")

```

# Codebook

A codebook (excel file) for the processed data file that explains what each variable represents.

Describe the variables so that other people understand what they represent. A verbal description of the variable and its usage in the analysis.

```{r}
if(!file.exists("../data/processed/data_processed_codebook.xlsx")){
  # convert the column names to a df
  codebook_template <- data.frame(variable =
                                    colnames(data_processed)) %>%
    mutate(explanation = NA)
  # write to disk as an excel file
    write.xlsx(codebook_template, file =
               "../data/processed/data_processed_codebook.xlsx")
}
```

# Session info

```{r}
sessionInfo()
```
